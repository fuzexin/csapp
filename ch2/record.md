# 第二章家庭作业 
## 2.55 
在你能够访问的不同机器上，使用show_bytes（文件show-bytes.c）编译并运行示例代码。确定这些机器使用的字节顺序。
program: show_bytes.c, check_endian.c
一个多字节的程序对象，被存储为连续的字节序列，各个字节序列之间的排列规则有两种：大端法（big endian）和小端法(little endian)。例如一个整数的十六进制为`0x01234567`，大端法的排列顺序为`01 23 45 67`，小端法的排列顺序为
`67 45 23 01`。
## 2.59
编写一个C表达式，它生成一个字，由x的最低有效字节和y中剩下的字节组成。对于运算数`x=0x89ABCDEF`和`y=0x76543210`,他就得到`0x765432EF`。
program: byte_change.c.
1. 一个字，含有4个字节，采用unsigned int比较合适；
2. 判断大小端机大端机:
   1. 大端机：x取尾字节，y取首字节到【尾字节-1】；
   2. 小端机：x取首字节，y取【首字节+1】到尾字节；

## 2.60
假设我们将一个$\omega$位的字中的字节从0（最低位）到$\omega/8-1$（最高位）编号。写出下面C函数的代码，它会返回一个无符号的值，其中参数x的字节i被替换成字节b：
`unsiged replace_byte(unsiged x, int i, unsigned char b);`
以下示例，说明了这个函数该如何工作：
`repalce_byte(0x12345678, 2, 0xAB) -->  0x12AB5678`
`repalce_byte(0x12345678, 0, 0xAB) -->  0x123456AB`
[code](./replace_byte.c)
是否也要判断大小端？
大端：12 34 56 78, 从后往前数
小端：78 56 34 12, 从前往后数